>>内部排序算法从三个方面来比较：
1、时间复杂度
简单选择排序（选择排序）、直接插入排序（插入排序）、冒泡排序（交换排序）作为三类排序的基础
平均情况下的时间复杂度都为O（n^2），直接插入和冒泡在理想情况下时间复杂度可以达到O(n)，简单选择排序的时间复杂度与序列的初始状态无关
希尔排序：插入排序的扩展，对较大规模的排序都有很高的效率，但是目前未得出其精确的渐进时间
堆排序：基于堆的一类选择排序，可以在线性时间内完成建堆，并在O(nlog2 n)内完成排序
快速排序：基于分治法的一类交换排序，在最坏情况下时间回达到O(n^2)，但是快排平均可以达到O(nlog2 n)
归并排序：基于分治法，它分割子序列与初始序列的排列无关，它的最好、最坏、平均时间复杂度都是O(nlog2 n)
2、空间复杂度
简单选择排序、插入排序、冒泡排序、希尔排序、堆排序都仅需要借助常数个辅助空间，只需要O(1)
快速排序在空间上只使用一个小的辅助栈，平均需要O(log2 n)，最坏情况下会增长到O(n)
二路归并在合并中需要借助较多的辅助空间用于元素复制，大小为O(n)
3、稳定性
稳定：插入、冒泡、归并、基数
不稳定：简单选择、快速、希尔、堆
4、各种排序算法比较
见 sort/src/排序算法比较.png

>>内部排序算法的应用
1、若n较小（n≤50），采用直接插入或者简单选择
但是直接插入移动次数比简单选择多，当记录本身信息量较大时，采用简单选择较好
2、若序列已经基本有序，选用直接插入或者冒泡
3、若n较大，则应采用时间复杂度为O(nlog2 n)的排序方法：快排、堆排序、归并排序
快排是目前基于比较的内部排序法中最好的方法，当待排序的关键字是随机分布时，快排的平均时间最短
堆排序所需要的辅助空间少于快排，并且它在最好、最坏都是O(nlog2 n)，不会出现快排的最坏情况O(n^2)
但是快排和堆排序都不稳定的，如果需要稳定可以采用归并排序。
对归并排序进行改进：与直接插入排序结合在一起，先利用直接插入求得较长的有序子序列，然后在两两归并，直接插入是稳定的，因此改进后的归并排序也是稳定的
4、在基于比较的排序方法中（除基数排序以外）
当文件的n个关键字随机分布时，任何借助于比较的排序算法，至少需要O(nlog2 n)时间
5、若n很大，记录的关键字为数较少，且可分解时，采用基数排序
6、记录本身信息量很大，为了避免耗费大量时间移动记录，可以采用链表作为存储结构

试题7.6
1 2 3 4 5 6 7 8 9 10 11
a c c | a b a d d c  a? source
a c c | a b a a c c  d	answer
√ √ √ √ √ √ √ x x √  x
4.1 I\IV\VI .2 II\VI\VII .3 I\IV
fix:
9.堆是用于排序的，在查找时它是无序的
11.希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，时间复杂度会增加


